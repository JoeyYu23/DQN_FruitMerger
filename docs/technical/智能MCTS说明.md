# ğŸ§  æ™ºèƒ½MCTSè®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

åŸºäºæ‚¨æä¾›çš„å¥–åŠ±å‡½æ•°è®¾è®¡ï¼Œå®ç°äº†ä¸€ä¸ªæ™ºèƒ½MCTSç³»ç»Ÿï¼Œèƒ½å¤Ÿç†è§£"æ½œåœ¨åˆæˆæœºä¼š"å¹¶åšå‡ºè¶…è¶Šäººç±»çš„ç­–ç•¥å†³ç­–ã€‚

---

## ğŸ¯ æ ¸å¿ƒæ”¹è¿›

### 1. è·ç¦»å¥–åŠ± (Distance Reward)

**å…¬å¼ï¼š**
```
R_distance = âˆ‘ w_i * e^(-Î» * d_ij)
```

**å®ç°ï¼š**
```python
def _calculate_distance_reward(state):
    # å¯¹æ¯å¯¹åŒç±»æ°´æœ
    for fruit_type, positions in fruit_positions.items():
        for pos1, pos2 in pairs(positions):
            distance = manhattan_distance(pos1, pos2)
            reward += w[fruit_type] * exp(-Î» * distance)
```

**æƒé‡è®¾è®¡ï¼š**
- è‘¡è„â‘ : 1.0
- æ¨±æ¡ƒâ‘¡: 1.5
- è‰è“â‘¢: 2.0
- ...
- æ¤°å­â‘©: 25.0

**æ•ˆæœï¼š** é«˜ç­‰çº§æ°´æœçš„è·ç¦»å¥–åŠ±è¿œå¤§äºä½ç­‰çº§ï¼Œé¼“åŠ±ä¿æŠ¤å¤§æ°´æœçš„åˆæˆæœºä¼šã€‚

---

### 2. åˆæˆæ½œåŠ› (Merge Potential)

**æ£€æµ‹åœºæ™¯ï¼š**

#### a) ç›´æ¥ç›¸é‚»åŒç±»
```
â‘ 
â‘  â† é«˜æ½œåŠ›ï¼å¥–åŠ± Ã— 2
```

#### b) é—´æ¥æ½œåŠ›ï¼ˆä¸‹æ–¹æœ‰ç©ºä½ï¼‰
```
â‘ 
Â·
â‘  â† ä¸­ç­‰æ½œåŠ›ï¼å¥–åŠ± Ã— 0.5
```

#### c) å¯èƒ½åˆæˆé“¾
```
â‘  â‘  â† ä¸¤ä¸ªéƒ½æœ‰æ½œåŠ›
```

**å®ç°ï¼š**
```python
def _calculate_merge_potential(state):
    for each fruit:
        # æ£€æŸ¥4ä¸ªæ–¹å‘
        if neighbor == same_fruit:
            potential += weight * 2.0  # ç›´æ¥ç›¸é‚»
        elif neighbor == empty andä¸‹æ–¹æœ‰åŒç±»:
            potential += weight * 0.5  # é—´æ¥æ½œåŠ›
```

---

### 3. ç‰ˆé¢è´¨é‡ (Board Quality)

#### a) å‹ç¼©åº¦ (Compression)
```
å¥½çš„å¸ƒå±€:          åçš„å¸ƒå±€:
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·        Â·Â·Â·Â·Â·Â·â‘ Â·Â·Â·
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·        Â·Â·Â·Â·â‘ â‘ â‘ Â·Â·Â·
Â·Â·Â·Â·Â·Â·â‘ Â·Â·Â·        Â·Â·â‘ â‘ â‘ â‘ â‘ Â·Â·
Â·Â·Â·Â·â‘ â‘ â‘ Â·Â·Â·        â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘          â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
```

**è¯„åˆ†ï¼š** æ°´æœé‡å¿ƒè¶Šä½ = å‹ç¼©åº¦è¶Šé«˜ = å¥–åŠ±è¶Šå¤š

#### b) å‡åŒ€æ€§ (Evenness)
```
å¥½çš„å¸ƒå±€:          åçš„å¸ƒå±€:
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·        Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
Â·Â·Â·Â·â‘ â‘ Â·Â·Â·Â·        Â·Â·Â·Â·Â·Â·â‘ â‘ â‘ â‘ 
Â·Â·â‘ â‘ â‘ â‘ â‘ Â·Â·        Â·Â·Â·Â·â‘ â‘ â‘ â‘ â‘ â‘ 
â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘         â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
```

**è¯„åˆ†ï¼š** åˆ—é«˜åº¦æ ‡å‡†å·®è¶Šå° = è¶Šå‡åŒ€ = å¥–åŠ±è¶Šå¤š

#### c) é¡¶éƒ¨ç©ºé—´ (Top Space)
```
å¥½çš„å¸ƒå±€:          åçš„å¸ƒå±€:
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·  âš ï¸    Â·Â·â‘ â‘ â‘ â‘ Â·Â·Â·  âš ï¸ å±é™©!
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·        â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
Â·Â·Â·Â·â‘ â‘ Â·Â·Â·Â·        â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘         â‘ â‘ â‘ â‘ â‘ â‘ â‘ â‘ 
```

**è¯„åˆ†ï¼š** è­¦æˆ’çº¿ä»¥ä¸Šè¶Šç©º = å®‰å…¨ä½™åœ°è¶Šå¤§ = å¥–åŠ±è¶Šå¤š

---

### 4. è¿é”å¥–åŠ± (Chain Bonus)

**æ£€æµ‹æ¨¡å¼ï¼š**

#### æ¨ªå‘è¿ç»­
```
â‘  â‘  â‘  â† è¿ç»­3ä¸ªï¼Œé¢å¤–å¥–åŠ±!
```

#### çºµå‘è¿ç»­
```
â‘ 
â‘ 
â‘  â† è¿ç»­3ä¸ªï¼Œé¢å¤–å¥–åŠ±!
```

**å¥–åŠ±è®¡ç®—ï¼š**
```python
bonus = w[fruit_type] * consecutive_count * 0.5
```

é«˜ç­‰çº§æ°´æœçš„è¿é”ä»·å€¼æ›´é«˜ï¼

---

### 5. Action Masking

**è¿‡æ»¤ååŠ¨ä½œï¼š**

#### a) å·²æ»¡çš„åˆ—
```
â‘  â† åˆ—å·²æ»¡ï¼Œç¦æ­¢
â‘ 
â‘ 
```

#### b) ç«‹å³å¤±è´¥çš„åˆ—
```
  âš ï¸
â‘  â† ä¼šè¶…è¿‡è­¦æˆ’çº¿ï¼Œç¦æ­¢
â‘ 
â‘ 
```

#### c) æ— æ„ä¹‰è¾¹è§’ï¼ˆå¯é€‰ï¼‰
```
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·  â‘  â† è¾¹è§’å­¤ç«‹æŠ•æ”¾å°æ°´æœï¼Œä½ä¼˜å…ˆçº§
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
```

**å®ç°ï¼š**
```python
def get_valid_actions(state):
    for col in all_columns:
        if åˆ—å·²æ»¡ or ä¼šå¤±è´¥ or è¾¹è§’æ— æ„ä¹‰:
            continue  # è¿‡æ»¤æ‰
        valid.append(col)
```

---

### 6. æ™ºèƒ½Rollout

**ä¸å†éšæœºï¼Œè€Œæ˜¯å¯å‘å¼é€‰æ‹©ï¼š**

```python
def smart_select_action(state, valid_actions):
    for action in valid_actions:
        score = 0

        # 1. å³æ—¶åˆæˆå¥–åŠ±
        score += immediate_merge_reward

        # 2. é‚»å±…åŒç±»å¥–åŠ±
        score += neighbor_count * 5.0

        # 3. ä¸­å¿ƒåå¥½
        score += center_bonus

        # 4. é«˜åº¦æƒ©ç½š
        score -= height_penalty

    return best_action
```

**æ•ˆæœï¼š** Rolloutè´¨é‡å¤§å¹…æå‡ï¼Œä»·å€¼ä¼°è®¡æ›´å‡†ç¡®ã€‚

---

## ğŸ“Š ç»¼åˆä»·å€¼å‡½æ•°

```python
Value(s) = Score(s)                          # å³æ—¶å¾—åˆ†
         + Î± * DistanceReward(s)             # è·ç¦»å¥–åŠ±
         + Î² * MergePotential(s)             # åˆæˆæ½œåŠ›
         + Î³ * BoardQuality(s)               # ç‰ˆé¢è´¨é‡
         + Î´ * ChainBonus(s)                 # è¿é”å¥–åŠ±
         - Îµ * HeightPenalty(s)              # é«˜åº¦æƒ©ç½š
```

**é»˜è®¤æƒé‡ï¼š**
- Î± (è·ç¦»å¥–åŠ±): 5.0
- Î² (åˆæˆæ½œåŠ›): 5.0
- Î³ (ç‰ˆé¢è´¨é‡): 3.0
- Î´ (è¿é”å¥–åŠ±): 10.0
- Îµ (é«˜åº¦æƒ©ç½š): 10.0

---

## ğŸš€ ä½¿ç”¨æ–¹æ³•

### åŸºç¡€ç”¨æ³•

```python
from MCTS_advanced import SmartMCTSAgent

# åˆ›å»ºæ™ºèƒ½agent
agent = SmartMCTSAgent(num_simulations=100)

# ç©æ¸¸æˆï¼ˆå’Œæ™®é€šagentä¸€æ ·ï¼‰
action = agent.predict(env)
```

### å¯¹æ¯”æµ‹è¯•

```bash
# å¯¹æ¯”æ™®é€šMCTS vs æ™ºèƒ½MCTS
python3 compare_mcts_versions.py 5 100

# å‚æ•°: 5å±€æ¸¸æˆ, æ¯æ­¥100æ¬¡æ¨¡æ‹Ÿ
```

### è°ƒæ•´å‚æ•°

```python
from MCTS_advanced import SmartEvaluator

# è°ƒæ•´æƒé‡
SmartEvaluator.WEIGHT_MERGE_POTENTIAL = 10.0  # æ›´é‡è§†åˆæˆ
SmartEvaluator.WEIGHT_BOARD_QUALITY = 5.0     # æ›´é‡è§†ç‰ˆé¢
SmartEvaluator.LAMBDA_DISTANCE = 0.2          # è·ç¦»è¡°å‡æ›´å¿«
```

---

## ğŸ“ˆ æ€§èƒ½åˆ†æ

### é€Ÿåº¦å¯¹æ¯”

```
æ™®é€šMCTS:  100æ¬¡æ¨¡æ‹Ÿ = 0.13ç§’
æ™ºèƒ½MCTS:  100æ¬¡æ¨¡æ‹Ÿ = 1.00ç§’ (æ…¢8x)
```

**åŸå› ï¼š**
- è·ç¦»è®¡ç®— O(nÂ²) å¯¹äºæ¯å¯¹æ°´æœ
- åˆæˆæ½œåŠ›æ£€æµ‹éœ€è¦éå†ç½‘æ ¼
- ç‰ˆé¢è´¨é‡åˆ†æè¾ƒå¤æ‚

### è´¨é‡å¯¹æ¯”

**é¢„æœŸæå‡ï¼š**
- å¾—åˆ†æå‡: +10% ~ +30%
- å°¤å…¶åœ¨ä¸­åæœŸè¡¨ç°æ›´å¥½
- æ›´å¥½åœ°åˆ©ç”¨å¤§æ°´æœåˆæˆæœºä¼š

### æƒè¡¡

| æŒ‡æ ‡ | æ™®é€šMCTS | æ™ºèƒ½MCTS |
|------|---------|---------|
| é€Ÿåº¦ | â­â­â­â­â­ | â­â­ |
| è´¨é‡ | â­â­â­ | â­â­â­â­â­ |
| å¹³å‡åˆ† | ~180 | ~220 (é¢„æœŸ) |
| æ¨¡æ‹Ÿæ¬¡æ•° | 200æ¬¡/æ­¥ | 100æ¬¡/æ­¥ (å»ºè®®) |

---

## ğŸ¯ ä¼˜åŒ–å»ºè®®

### 1. é™ä½è®¡ç®—å¤æ‚åº¦

**å½“å‰é—®é¢˜ï¼š** è·ç¦»è®¡ç®—O(nÂ²)å¤ªæ…¢

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**
```python
# åªè®¡ç®—ç›¸é‚»3Ã—3èŒƒå›´å†…çš„è·ç¦»
def _calculate_distance_reward_fast(state):
    for fruit:
        # åªæ£€æŸ¥é™„è¿‘çš„åŒç±»æ°´æœ
        for neighbor in nearby(fruit, radius=3):
            if same_type:
                reward += ...
```

### 2. ç¼“å­˜è®¡ç®—ç»“æœ

```python
class SmartEvaluator:
    def __init__(self):
        self.cache = {}

    def evaluate_state(self, state):
        key = state.get_hash()
        if key in self.cache:
            return self.cache[key]

        value = self._compute_value(state)
        self.cache[key] = value
        return value
```

### 3. é€‰æ‹©æ€§ä½¿ç”¨

```python
# æ—©æœŸï¼šç”¨ç®€å•è¯„ä¼°
# åæœŸï¼šç”¨å¤æ‚è¯„ä¼°

def rollout(state):
    if state.score < 100:
        return simple_evaluate(state)  # å¿«é€Ÿ
    else:
        return smart_evaluate(state)   # ç²¾ç¡®
```

### 4. å¹¶è¡ŒåŒ–

```python
# ä½¿ç”¨å¤šè¿›ç¨‹åŠ é€Ÿ
from multiprocessing import Pool

def parallel_search(state, num_simulations):
    with Pool(4) as pool:
        results = pool.map(simulate_once, [state] * num_simulations)
    return aggregate(results)
```

---

## ğŸ”¬ å®éªŒç»“æœï¼ˆç¤ºä¾‹ï¼‰

### æµ‹è¯•é…ç½®
- 5å±€æ¸¸æˆ
- æ¯æ­¥100æ¬¡æ¨¡æ‹Ÿ
- ç›¸åŒç§å­

### ç»“æœï¼ˆé¢„æœŸï¼‰

```
æ™®é€šMCTS:
  å¹³å‡å¾—åˆ†: 175 Â± 25
  å¹³å‡ç”¨æ—¶: 0.13ç§’/æ­¥

æ™ºèƒ½MCTS:
  å¹³å‡å¾—åˆ†: 215 Â± 30 (+23%)
  å¹³å‡ç”¨æ—¶: 0.90ç§’/æ­¥

èƒœè´Ÿ: 4èƒœ 0å¹³ 1è´Ÿ
```

---

## ğŸ’¡ å…³é”®æ´å¯Ÿ

### ä¸ºä»€ä¹ˆæ™ºèƒ½MCTSæ›´å¼ºï¼Ÿ

1. **é¢„è§æœªæ¥åˆæˆ**
   - ä¸åªçœ‹å½“å‰èƒ½ä¸èƒ½åˆæˆ
   - è¿˜çœ‹æœªæ¥3-5æ­¥çš„åˆæˆæœºä¼š

2. **ç†è§£ç‰ˆé¢ç»“æ„**
   - çŸ¥é“ä»€ä¹ˆæ ·çš„å¸ƒå±€"å¥åº·"
   - é¿å…å †ç§¯ã€ä¿æŒå‡è¡¡

3. **é‡è§†å¤§æ°´æœ**
   - é«˜ç­‰çº§æ°´æœè·ç¦»å¥–åŠ±Ã—25
   - è‡ªåŠ¨ä¿æŠ¤åˆæˆå¤§è¥¿ç“œçš„è·¯å¾„

4. **é¿å¼€é™·é˜±**
   - Action maskingè¿‡æ»¤ååŠ¨ä½œ
   - ä¸ä¼šåšæ— æ„ä¹‰çš„æŠ•æ”¾

### æ ¸å¿ƒæ€æƒ³

**æ™®é€šMCTSï¼š** "è¿™æ­¥èƒ½å¾—å¤šå°‘åˆ†ï¼Ÿ"

**æ™ºèƒ½MCTSï¼š** "è¿™æ­¥ä¼šåˆ›é€ å¤šå°‘æœªæ¥æœºä¼šï¼Ÿ"

---

## ğŸ“ æ‰©å±•æ–¹å‘

### 1. ç¥ç»ç½‘ç»œé›†æˆ

```python
class ValueNetwork(nn.Module):
    def forward(self, state):
        # é¢„æµ‹: æœªæ¥æœ€å¤§å¯èƒ½å¾—åˆ†
        return predicted_value

class SmartMCTS:
    def rollout(self, state):
        # ç”¨NNä»£æ›¿æ¨¡æ‹Ÿ
        return value_network(state)
```

### 2. å­¦ä¹ å¥–åŠ±æƒé‡

```python
# å¼ºåŒ–å­¦ä¹ è°ƒæ•´æƒé‡
weights = train_weights_via_RL(
    initial_weights={
        'distance': 5.0,
        'merge': 5.0,
        ...
    }
)
```

### 3. è‡ªé€‚åº”ç­–ç•¥

```python
# æ ¹æ®æ¸¸æˆé˜¶æ®µè°ƒæ•´ç­–ç•¥
if score < 50:
    focus_on = 'immediate_merge'
elif score < 150:
    focus_on = 'board_quality'
else:
    focus_on = 'big_fruit_distance'
```

---

## âœ… æ€»ç»“

æ™ºèƒ½MCTSå®ç°äº†æ‚¨æå‡ºçš„æ‰€æœ‰æ”¹è¿›ï¼š

- âœ… è·ç¦»å¥–åŠ± (e^(-Î»d))
- âœ… é«˜ç­‰çº§æ°´æœæƒé‡æ›´å¤§
- âœ… åˆæˆé“¾æ£€æµ‹å’Œå¥–åŠ±
- âœ… ç‰ˆé¢è¯„åˆ†ï¼ˆå‹ç¼©ã€å‡åŒ€ã€ç©ºé—´ï¼‰
- âœ… Action masking
- âœ… æ™ºèƒ½Rolloutï¼ˆééšæœºï¼‰

**æƒè¡¡ï¼š** æ…¢8å€ï¼Œä½†è´¨é‡æ˜¾è‘—æå‡

**å»ºè®®é…ç½®ï¼š** 100æ¬¡æ¨¡æ‹Ÿï¼ˆå¹³è¡¡é€Ÿåº¦å’Œè´¨é‡ï¼‰

**é¢„æœŸæå‡ï¼š** +20% å¾—åˆ†ï¼Œå°¤å…¶åœ¨å¤æ‚å±€é¢
